<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LUXPLAY Neural Vortex Background Test</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #171717;
            color: #e5e5e5;
            font-family: system-ui, -apple-system, sans-serif;
            overflow: hidden;
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
        }
        .content {
            position: relative;
            z-index: 10;
            padding: 2rem;
            text-align: center;
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(8px);
            margin: 2rem;
            border-radius: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #4338ca, #7c3aed);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        p {
            font-size: 1.2rem;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="content">
        <h1>LUXPLAY</h1>
        <p>Neural Vortex Background Test</p>
        <p>Move your mouse/cursor to interact with the background</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            console.error('WebGL not supported');
            document.body.innerHTML = '<h1 style="text-align: center; margin-top: 50vh; transform: translateY(-50%);">WebGL not supported</h1>';
        }

        // Vertex shader
        const vsSource = `
            precision mediump float;
            attribute vec2 a_position;
            varying vec2 vUv;
            void main() {
                vUv = .5 * (a_position + 1.);
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        // Fragment shader - LUXPLAY dark theme optimized
        const fsSource = `
            precision mediump float;
            varying vec2 vUv;
            uniform float u_time;
            uniform float u_ratio;
            uniform vec2 u_pointer_position;
            uniform float u_scroll_progress;
            uniform float u_intensity;
            
            vec2 rotate(vec2 uv, float th) {
                return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;
            }
            
            float neuro_shape(vec2 uv, float t, float p) {
                vec2 sine_acc = vec2(0.);
                vec2 res = vec2(0.);
                float scale = 8. * u_intensity;
                for (int j = 0; j < 15; j++) {
                    uv = rotate(uv, 1.);
                    sine_acc = rotate(sine_acc, 1.);
                    vec2 layer = uv * scale + float(j) + sine_acc - t;
                    sine_acc += sin(layer) + 2.4 * p;
                    res += (.5 + .5 * cos(layer)) / scale;
                    scale *= (1.2);
                }
                return res.x + res.y;
            }
            
            void main() {
                vec2 uv = .5 * vUv;
                uv.x *= u_ratio;
                vec2 pointer = vUv - u_pointer_position;
                pointer.x *= u_ratio;
                float p = clamp(length(pointer), 0., 1.);
                p = .5 * pow(1. - p, 2.);
                float t = .001 * u_time;
                vec3 color = vec3(0.);
                float noise = neuro_shape(uv, t, p);
                noise = 1.2 * pow(noise, 3.);
                noise += pow(noise, 10.);
                noise = max(.0, noise - .5);
                noise *= (1. - length(vUv - .5));
                
                // LUXPLAY dark theme colors
                color = vec3(0.26, 0.22, 0.79); // Base LUXPLAY primary color
                color = mix(color, vec3(0.42, 0.34, 0.88), 0.32 + 0.16 * sin(2.0 * u_scroll_progress + 1.2));
                color += vec3(0.18, 0.15, 0.65) * sin(2.0 * u_scroll_progress + 1.5);
                
                // Enhanced for dark mode contrast
                color = color * noise * u_intensity * 1.2;
                gl_FragColor = vec4(color, noise * 0.8);
            }
        `;

        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = compileShader(vsSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fsSource, gl.FRAGMENT_SHADER);

        if (!vertexShader || !fragmentShader) {
            console.error('Failed to compile shaders');
        }

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // Set up geometry
        const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // Get uniform locations
        const uTime = gl.getUniformLocation(program, 'u_time');
        const uRatio = gl.getUniformLocation(program, 'u_ratio');
        const uPointerPosition = gl.getUniformLocation(program, 'u_pointer_position');
        const uScrollProgress = gl.getUniformLocation(program, 'u_scroll_progress');
        const uIntensity = gl.getUniformLocation(program, 'u_intensity');

        let mouseX = 0, mouseY = 0;

        // Resize function
        function resizeCanvas() {
            const devicePixelRatio = Math.min(window.devicePixelRatio, 2);
            canvas.width = window.innerWidth * devicePixelRatio;
            canvas.height = window.innerHeight * devicePixelRatio;
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            if (uRatio) {
                gl.uniform1f(uRatio, canvas.width / canvas.height);
            }
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Mouse tracking
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        // Animation loop
        function render() {
            const currentTime = performance.now();
            
            // Update uniforms
            if (uTime) gl.uniform1f(uTime, currentTime);
            if (uPointerPosition) {
                gl.uniform2f(uPointerPosition, 
                    mouseX / window.innerWidth, 
                    1 - mouseY / window.innerHeight
                );
            }
            if (uScrollProgress) {
                gl.uniform1f(uScrollProgress, 0);
            }
            if (uIntensity) {
                gl.uniform1f(uIntensity, 1.0);
            }
            
            // Clear and draw
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>